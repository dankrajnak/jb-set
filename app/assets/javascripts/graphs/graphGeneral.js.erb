/*
 * Created by danielkrajnak on 6/07/17.
 */
function createGeneralGraph(graphWidth, graphHeight, graphMargins) {

	var margin = (typeof graphMargins === 'undefined') ? {
		top: 20,
		right: 30,
		bottom: 30,
		left: 40
	} : graphMargins;
	var width = (typeof graphWidth === 'undefined') ? $("#graph-row").width() : grpahWidth;
	var height = (typeof graphHeight === 'undefined') ? window.innerHeight / 2 : graphHeight;
	width -= margin.left + margin.right;
	height -= margin.top + margin.bottom;
	var oldQuestionType = '';
	var oldGraph = '';

	//Graphs
	var numberGraph = d3.select("#general-graph-number");
	var multipleChoiceGraph = d3.select('#general-graph-multiple-choice');
	var longResponseGraph = d3.select('#general-graph-long-response');
	var shortResponseGraph = d3.select('#general-graph-short-response');
	var trueFalseGraph = d3.select('#general-graph-true-false');
	var yesNoGraph = d3.select('#general-graph-yes-no');


	//Graph Data
	var currentGraphData = {};
	var numberGraphData = drawNumber(numberGraph);
	var multiplceChoiceGraphData = drawMultipleChoice(multipleChoiceGraph);
	var longResponseGraphData = drawLongResponse(longResponseGraph);
	var shortResponseGraphData = drawShortResponse(shortResponseGraph);
	var trueFalseGraphData = drawTrueFalse(trueFalseGraph);
	var yesNoGraphData = drawYesNo(yesNoGraph);



	//Should inherit these through the prototype
	var jbCountries = [];
	var jbRegions = [];

	var graphsSetup = [];

	var animationDuration = 700;

	queue()
		.defer(d3.tsv, "<%= image_url('jb-countries.tsv') %>")
		.defer(d3.tsv, "<%= image_url('jb-regions.tsv') %>")
		.defer(d3.json, "/surveys.json")
		.await(handler);


	/**
	 * Watch the select groups.
	 * Get the data, call transition, when data is ready, draw the corresponding graph.
	 */
	function handler(error, countries, regions, surveys) {
		if (error) throw error;

		jbCountries = countries;
		jbRegions = regions;

		// Populate survey select
		surveys.forEach(function (survey) {
			$('#general-graph-select').append("<option value = \"" + survey.name + "\"> " + survey.name + "</option>");
		});
		var surveySelected = $('#general-graph-select option').filter(":selected").text();

		// Populate Question Select and Draw Graph
		populateQuestions(surveySelected);

		//Listen for change in survey
		$('#general-graph-select').change(function () {
			populateQuestions($('#general-graph-select option').filter(':selected').text())
		});

		//Listen for change in question
		$('#general-graph-question-select').change(function () {
			drawGraph($('#general-graph-question-select option').filter(':selected').val())
		});



	}

	function populateQuestions(survey) {
		d3.json("/surveys/" + encodeURI(survey.trim()) + ".json", function (error, survey) {
			if (error) throw error;

			//Remove current questions 
			$('#general-graph-question-select option').remove();

			//Add new quesitons
			survey.questions.forEach(function (q) {
				//Format multiple choice questions
				var name = (q.qtype === 'mc') ? q.name.split('[CHOICES]')[0] : q.name;
				//Disable headers
				var disabled = (q.qtype === 'h') ? "class=\"general-graph-header-option\" disabled" : '';
				$('#general-graph-question-select').append("<option value = \"" + q.id + ',' + q.qtype + "\" " + disabled + "> " + name + "</option>");
			});

			var questionSelected = $('#general-graph-question-select option').filter(":selected").val();
			drawGraph(questionSelected);

		});

	}

	/**
	 * Call transitions between graphs, then draw graphs passing in question
	 * data
	 */
	function drawGraph(questionInfo) {
		if (!questionInfo) return;

		var questionID = questionInfo.split(',')[0];
		var questionType = questionInfo.split(',')[1];
		var drawFunction, updateFunction, graph;

		switch (questionType) {
			case 'n':
				updateFunction = updateNumber;
				currentGraphData = numberGraphData;
				graph = numberGraph;
				break;
			case 'mc':
				updateFunction = function () {}
				currentGraphData = multiplceChoiceGraphData;
				graph = d3.select("#general-graph-multiple-choice");
				break;
			case 'sr':
				updateFunction = function () {}
				currentGraphData = shortResponseGraphData;
				graph = d3.select("#general-graph-short-response");
				break;
			case 'lr':
				updateFunction = updateLongResponse
				currentGraphData = longResponseGraphData;
				graph = d3.select("#general-graph-long-response");
				break;
			case 'tf':
				updateFunction = function () {}
				currentGraphData = trueFalseGraphData;
				graph = d3.select("#general-graph-true-false");
				break;
			case 'yn':
				updateFunction = function () {}
				currentGraphData = yesNoGraphData;
				graph = d3.select("#general-graph-yes-no");
				break;
			default:
				updateFunction = function () {}
				currentGraphData = longResponseGraphData;
				graph = d3.select("#general-graph-long-response");

				break;
		}

		d3.json('/questions/' + questionID + '.json', function (error, question) {
			//Draw appropriate graph
			if (error) throw error;
			currentGraphData.question = question;
			d3.transition()
				.duration(900)
				.each(function () {
					updateFunction(currentGraphData);
				});
			oldGraph = graph;
			oldQuestionType = questionType;
		});

		//Transistion graphs out and in if the type of question changes
		if (oldQuestionType !== questionType) {
			if (oldGraph) {
				hideGraph(oldGraph);

				setTimeout(function () {
					showGraph(graph);
				}, animationDuration);
			}
		}
	}

	function hideGraph(graph) {
		graph.classed("fadeOut", true);
		setTimeout(function () {
			graph.style('display', 'none');
		}, animationDuration)
	}

	function showGraph(graph) {
		d3.select(".general-graph").style("display", "none");
		graph.style('display', "block");
		graph.classed("fadeOut", false);
	}

	function drawNumber(graph) {

		graph.attr("height", height + margin.top + margin.bottom).attr("width", width + margin.left + margin.right);

		var graphBase = graph.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var y = d3.scale.linear().range([height, 0]);
		var x = d3.scale.ordinal().rangeRoundBands([0, width], 0.01);

		var xAxis = d3.svg.axis().scale(x).orient("bottom");
		var yAxis = d3.svg.axis().scale(y).orient("left");

		//Attach axes
		graphBase.append("g").attr("class", "x-axis axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis);

		graphBase.append("g")
			.attr("class", "y-axis axis")
			.call(yAxis);

		return {
			graphBase: graphBase,
			scales: {
				y: y,
				x: x,
			},
			axes: {
				xAxis: xAxis,
				yAxis: yAxis
			}
		}
	}

	function updateNumber(gData) {
		var graphBase = gData.graphBase;
		var question = gData.question;
		var x = gData.scales.x;
		var y = gData.scales.y;
		var xAxis = gData.axes.xAxis;
		var yAxis = gData.axes.yAxis;

		if (question.answers.some(function (qa) {
				return typeof qa.region === "undefined";
			})) {
			//attach regions to answers.  Ugh, there's a better way to do this.
			question.answers.forEach(function (a) {
				a.region = jbRegions.find(function (region) {
					return (jbCountries.find(function (country) {
						return (country.name === a.country);
					}).region === region.id);
				})
			});
		}

		var bar = graphBase.selectAll(".bar").data(question.answers, function (d) {
			if (question.keys) {
				d.identifier = d.keyAnswers[0];
				return d.keyAnswers[0];
			} else {
				d.identifier = d.country;
				return d.country;
			}
		});

		var barEnter = bar.enter().insert("g", ".x-axis")
			.attr("class", "bar")
			.attr("fill-opacity", 0);



		barEnter.append("rect")
			.attr("class", function (d) {
				return d.region.abbreviation
			})
			.attr("width", 0)
			.attr("height", 0)
			.attr("transform", "translate(0, " + height + ")");


		y.domain([0, d3.max(question.answers, function (d) {
			return +d.answer; //coerce to number
		})]);

		x.domain(question.answers.sort(function (a, b) {
			if (+a.region.id === +b.region.id) {
				return a.country.localeCompare(b.country);
			}
			return +a.region.id - b.region.id;
		}).map(function (c) {
			if (question.keys) {
				return c.keyAnswers[0];
			}
			return c.country;
		}));


		var barUpdate = d3.transition(bar)
			.attr("transform", function (d) {
				return "translate(" + x(d.identifier) + ", 0)";
			})
			.style("fill-opacity", 1);

		barUpdate.select("rect")
			.attr("transform", function (d) {
				return "translate(0, " + y(+d.answer) + ")"
			})
			.attr("height", function (d) {
				return height - y(+d.answer);
			})
			.attr("width", x.rangeBand());

		var barExit = d3.transition(bar.exit())
			.style("fill-opacity", 0)
			.remove()

		barExit.select("rect")
			.attr("transform", "translate(0," + height + ")")
			.attr("height", 0);

		d3.transition(graphBase).select(".y-axis").call(yAxis);
		d3.transition(graphBase).select(".x-axis").call(xAxis);

	}

	function drawMultipleChoice(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("Multiple choice questions aren't supported yet :(  Try another question!");
		return graph;
	}

	function drawShortResponse(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("Short response questions aren't supported yet :(  Try another question!");
		return graph;
	}

	function drawLongResponse(graph) {
		console.log(longResponseGraph[0][0]);
		return graph;
	}

	function updateLongResponse(gData) {
		var graph = longResponseGraph;
		var question = gData;
		var items = longResponseGraph.selectAll('.carousel-item').data(question.answers)

		console.log(longResponseGraph);

	}

	function drawTrueFalse(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("True/False questions aren't supported yet :(  Try another question!");
	}

	function drawYesNo(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("Yes/No questions aren't supported yet :(  Try another question!");
		return graph;
	}

}
