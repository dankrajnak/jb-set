/*
 * Created by danielkrajnak on 6/07/17.
 */
function createGeneralGraph(graphWidth, graphHeight, graphMargins) {

	var margin = (typeof graphMargins === 'undefined') ? {
		top: 20,
		right: 30,
		bottom: 30,
		left: 40
	} : graphMargins;
	var width = (typeof graphWidth === 'undefined') ? $("#graph-row").width() : grpahWidth;
	var height = (typeof graphHeight === 'undefined') ? window.innerHeight / 2 : graphHeight;
	width -= margin.left + margin.right;
	height -= margin.top + margin.bottom;
	var oldQuestionType = '';
	var oldGraph = '';

	//Graphs
	var numberGraph = d3.select("#general-graph-number");
	var multipleChoiceGraph = d3.select('#general-graph-multiple-choice');
	var longResponseGraph = d3.select('#general-graph-long-response');
	var shortResponseGraph = d3.select('#general-graph-short-response');
	var trueFalseGraph = d3.select('#general-graph-true-false');
	var yesNoGraph = d3.select('#general-graph-yes-no');


	//Graph Data
	var currentGraphData = {};
	var numberGraphData = drawNumber(numberGraph);
	var multiplceChoiceGraphData = drawMultipleChoice(multipleChoiceGraph);
	var longResponseGraphData = drawLongResponse(longResponseGraph);
	var shortResponseGraphData = drawShortResponse(shortResponseGraph);
	var trueFalseGraphData = drawTrueFalse(trueFalseGraph);
	var yesNoGraphData = drawYesNo(yesNoGraph);



	//Should inherit these through the prototype
	var jbCountries = [];
	var jbRegions = [];

	var graphsSetup = [];

	var animationDuration = 700;

	queue()
		.defer(d3.tsv, "<%= image_url('jb-countries.tsv') %>")
		.defer(d3.tsv, "<%= image_url('jb-regions.tsv') %>")
		.defer(d3.json, "/surveys.json")
		.await(handler);


	/**
	 * Watch the select groups.
	 * Get the data, call transition, when data is ready, draw the corresponding graph.
	 */
	function handler(error, countries, regions, surveys) {
		if (error) throw error;

		jbCountries = countries;
		jbRegions = regions;

		// Populate survey select
		surveys.forEach(function (survey) {
			$('#general-graph-select').append("<option value = \"" + survey.name + "\"> " + survey.name + "</option>");
		});
		var surveySelected = $('#general-graph-select option').filter(":selected").text();

		// Populate Question Select and Draw Graph
		populateQuestions(surveySelected);

		//Listen for change in survey
		$('#general-graph-select').change(function () {
			populateQuestions($('#general-graph-select option').filter(':selected').text())
		});

		//Listen for change in question
		$('#general-graph-question-select').change(function () {
			drawGraph($('#general-graph-question-select option').filter(':selected').val())
		});



	}

	function populateQuestions(survey) {
		d3.json("/surveys/" + encodeURI(survey.trim()) + ".json", function (error, survey) {
			if (error) throw error;

			//Remove current questions 
			$('#general-graph-question-select option').remove();

			//Add new quesitons
			survey.questions.forEach(function (q) {
				//Format multiple choice questions
				var name = (q.qtype === 'mc') ? q.name.split('[CHOICES]')[0] : q.name;
				//Disable headers
				var disabled = (q.qtype === 'h') ? "class=\"general-graph-header-option\" disabled" : '';
				$('#general-graph-question-select').append("<option value = \"" + q.id + ',' + q.qtype + "\" " + disabled + "> " + name + "</option>");
			});

			var questionSelected = $('#general-graph-question-select option').filter(":selected").val();
			drawGraph(questionSelected);

		});

	}

	/**
	 * Call transitions between graphs, then draw graphs passing in question
	 * data
	 */
	function drawGraph(questionInfo) {
		if (!questionInfo) return;

		var questionID = questionInfo.split(',')[0];
		var questionType = questionInfo.split(',')[1];
		var updateFunction, graph;

		switch (questionType) {
			case 'n':
				updateFunction = updateNumber;
				currentGraphData = numberGraphData;
				graph = numberGraph;
				break;
			case 'mc':
				updateFunction = updateMultipleChoice;
				currentGraphData = multiplceChoiceGraphData;
				graph = d3.select("#general-graph-multiple-choice");
				break;
			case 'sr':
				updateFunction = function () {}
				currentGraphData = shortResponseGraphData;
				graph = d3.select("#general-graph-short-response");
				break;
			case 'lr':
				updateFunction = updateLongResponse
				currentGraphData = longResponseGraphData;
				graph = d3.select("#general-graph-long-response");
				break;
			case 'tf':
				updateFunction = function () {}
				currentGraphData = trueFalseGraphData;
				graph = d3.select("#general-graph-true-false");
				break;
			case 'yn':
				updateFunction = function () {}
				currentGraphData = yesNoGraphData;
				graph = d3.select("#general-graph-yes-no");
				break;
			default:
				updateFunction = function () {}
				currentGraphData = longResponseGraphData;
				graph = d3.select("#general-graph-long-response");

				break;
		}

		d3.json('/questions/' + questionID + '.json', function (error, question) {
			//Draw appropriate graph
			if (error) throw error;
			currentGraphData.question = question;
			d3.transition()
				.duration(1200)
				.ease("quad")
				.each(function () {
					updateFunction(currentGraphData);
				});
			oldGraph = graph;
			oldQuestionType = questionType;
		});

		//Transistion graphs out and in if the type of question changes
		if (oldQuestionType !== questionType) {
			if (oldGraph) {
				hideGraph(oldGraph);

				setTimeout(function () {
					showGraph(graph);
				}, animationDuration);
			}
		}
	}

	function hideGraph(graph) {
		graph.classed("fadeOut", true);
		setTimeout(function () {
			graph.style('display', 'none');
		}, animationDuration)
	}

	function showGraph(graph) {
		d3.select(".general-graph").style("display", "none");
		graph.style('display', "block");
		graph.classed("fadeOut", false);
	}


	/*--------------- Draw and Update Functions ---------------*/

	/*
	Each type of graph has an draw and an update function.  The draw function is for setup
	and is called only once at the beginning of this script.  The update function is called
	each time a graph of this type is viewed and updates the graph with the data from the question
	being viewed.
	*/

	function drawNumber(graph) {

		graph.attr("height", height + margin.top + margin.bottom).attr("width", width + margin.left + margin.right);

		var graphBase = graph.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var y = d3.scale.linear().range([height, 0]);
		var x = d3.scale.ordinal().rangeRoundBands([0, width], 0.01);

		var xAxis = d3.svg.axis().scale(x).orient("bottom");
		var yAxis = d3.svg.axis().scale(y).orient("left");

		//Attach axes
		graphBase.append("g").attr("class", "x-axis axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis);

		graphBase.append("g")
			.attr("class", "y-axis axis")
			.call(yAxis);

		return {
			graphBase: graphBase,
			scales: {
				y: y,
				x: x,
			},
			axes: {
				xAxis: xAxis,
				yAxis: yAxis
			}
		}
	}

	function updateNumber(gData) {
		var graphBase = gData.graphBase;
		var question = gData.question;
		var x = gData.scales.x;
		var y = gData.scales.y;
		var xAxis = gData.axes.xAxis;
		var yAxis = gData.axes.yAxis;

		if (question.answers.some(function (qa) {
				return typeof qa.region === "undefined";
			})) {
			//attach regions to answers.  Ugh, there's a better way to do this.
			question.answers.forEach(function (a) {
				a.region = jbRegions.find(function (region) {
					return (jbCountries.find(function (country) {
						return (country.name === a.country);
					}).region === region.id);
				})
			});
		}

		var bar = graphBase.selectAll(".bar").data(question.answers, function (d) {
			if (question.keys) {
				d.identifier = d.keyAnswers[0];
				return d.keyAnswers[0];
			} else {
				d.identifier = d.country;
				return d.country;
			}
		});

		var barEnter = bar.enter().insert("g", ".x-axis")
			.attr("class", "bar")
			.attr("fill-opacity", 0);



		barEnter.append("rect")
			.attr("class", function (d) {
				return d.region.abbreviation
			})
			.attr("width", 0)
			.attr("height", 0)
			.attr("transform", "translate(0, " + height + ")");


		y.domain([0, d3.max(question.answers, function (d) {
			return +d.answer; //coerce to number
		})]);

		x.domain(question.answers.sort(function (a, b) {
			if (+a.region.id === +b.region.id) {
				return a.country.localeCompare(b.country);
			}
			return +a.region.id - b.region.id;
		}).map(function (c) {
			if (question.keys) {
				return c.keyAnswers[0];
			}
			return c.country;
		}));


		var barUpdate = d3.transition(bar)
			.attr("transform", function (d) {
				return "translate(" + x(d.identifier) + ", 0)";
			})
			.style("fill-opacity", 1);

		barUpdate.select("rect")
			.attr("transform", function (d) {
				return "translate(0, " + y(+d.answer) + ")"
			})
			.attr("height", function (d) {
				return height - y(+d.answer);
			})
			.attr("width", x.rangeBand());

		var barExit = d3.transition(bar.exit())
			.style("fill-opacity", 0)
			.remove()

		barExit.select("rect")
			.attr("transform", "translate(0," + height + ")")
			.attr("height", 0);

		d3.transition(graphBase).select(".y-axis").call(yAxis);
		d3.transition(graphBase).select(".x-axis").call(xAxis);

	}

	function drawMultipleChoice(graph) {

		graph.attr("height", height + margin.top + margin.bottom).attr("width", width + margin.left + margin.right);

		var graphBase = graph.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
		var radius = Math.min(height / 2, width / 4);
		var pie = d3.layout.pie()
			.sort(null)
			.value(function (d) {
				return d.value;
			});

		var path = d3.svg.arc()
			.outerRadius(radius - 10)
			.innerRadius(0);

		var label = d3.svg.arc()
			.outerRadius(radius - 40)
			.innerRadius(radius - 40);

		var colors = ["#336699", "#FF6633", "#CC0066", "#FFCC33", "#FF3333", "#FF9933", "#009966", "#339933"];

		var defaultArc = d3.svg.arc().outerRadius(radius - 10).innerRadius(0); //margin of 10.

		return {
			graphBase: graphBase,
			radius: radius,
			pie: pie,
			path: path,
			label: label,
			colors: colors,
			defaultArc: defaultArc,
		};
	}

	function updateMultipleChoice(gData) {
		var graphBase = gData.graphBase;
		var radius = gData.radius;
		var question = gData.question;
		var pie = gData.pie;
		var path = gData.path;
		var label = gData.label;
		var colors = gData.colors;
		var defaultArc = gData.defaultArc;
		var colorIndex = 0;

		//Format data
		//Get choices.
		var choices = [];
		question.name.split("[CHOICES]")[1].split("|").forEach(function (choice, index) {
			if (choice !== "") {
				choices[index] = {
					name: choice,
					count: 0
				};
			}
		});

		//Count responses.
		question.answers.forEach(function (response) {
			choices.some(function (choice, index) {
				if (response.answer === choice.name) {
					choices[index].count++;
					return true;
				}
				return false;
			});
		});

		var total = choices.reduce(function (tot, choice) {
			return tot + choice.count;
		}, 0);

		choices.forEach(function (choice) {
			choice.value = choice.count / total;
		});
		choices = choices.filter(function (choice) {
			return (choice.value !== 0);
		})

		//Sort
		choices.sort(function (a, b) {
			return b.value - a.value;
		})
		var arc = graphBase.selectAll(".arc")
			.data(pie(choices), function (d) {
				return d.data.name;
			});

		var arcEnter = arc.enter().append("g").attr("class", "arc").style("fill-opacity", 0);

		arcEnter.append("path").attr("d", defaultArc).attr("fill", function (d) {
			return colors[colorIndex++ % colors.length];
		});

		var textSpace = 15
		var textArea = arcEnter.append("g").attr("class", "pie-text-area")
			.attr("transform", function (d) {
				return "translate(" + label.centroid(d) + ")";
			})
			.attr("dy", "2.4em")
			.style("max-width", radius)
			.attr("title", function (d) {
				return d.data.name + ", " + Math.round(d.data.value * 100) + "%";
			})

		textArea.append("text")
			.attr("class", "pie-info")
			.text(function (d) {
				return d.data.name;
			})

		textArea.append("text")
			.attr("class", "pie-value").attr("dy", "1em")
			.text(function (d) {
				return Math.round(d.data.value * 100) + "%";
			});


		//Update
		var arcUpdate = d3.transition(arc).style("fill-opacity", 1);
		arcUpdate.select("path").attrTween("d", function (arc) {
				return tweenPie(defaultArc, {
						startAngle: 0,
						endAngle: 0
					},
					arc);
			}).style("fill-opacity", 1)
			.duration(3000)
			.ease("elastic")

		arcUpdate.select(".pie-text-area").attr("transform", function (d) {
			return "translate(" + label.centroid(d) + ")";
		}).attr("title", function (d) {
			return d.data.name + ", " + Math.round(d.data.value * 100) + "%";
		});

		arcUpdate.select(".pie-info")
			.text(function (d) {
				return d.data.name;
			})

		arcUpdate.select(".pie-value").text(function (d) {
			return Math.round(d.data.value * 100) + "%";
		});


		//exit
		var arcExit = d3.transition(arc.exit())
			.style("fill-opacity", 0)
			.remove();

		arcExit.select("path")
			.attrTween("d", function (arc) {
				return tweenPie(defaultArc, arc, {
					startAngle: 0,
					endAngle: 0,
				});
			})

		arc.exit().select(".pie-text-area").remove();

	}

	function tweenPie(arc, from, to) {
		var interp = d3.interpolate(from, to);
		return function (t) {
			return arc(interp(t))
		}
	}

	function drawShortResponse(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("Short response questions aren't supported yet :(  Try another question!");
		return graph;
	}

	function drawLongResponse(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("Long response questions aren't supported yet :(  Try another question!");
		return graph;
	}

	function updateLongResponse(gData) {
		var graph = longResponseGraph.select(".carousel-inner");
		var question = gData;

		var items = graph.selectAll('.carousel-item').data(question.answers, function (d) {
			if (question.keys) {
				d.identifier = d.keyAnswers[0];
				return d.keyAnswers[0];
			} else {
				d.identifier = d.country;
				return d.country;
			}
		});

		var itemsEnter = items.enter().insert("div")
			.attr("class", "carousel-item");

		itemsEnter.append("p").attr("class", "d-block").html(function (d) {
			return d.answer
		});

		var itemsExt = bar.exit().remove();

	}

	function drawTrueFalse(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("True/False questions aren't supported yet :(  Try another question!");
	}

	function drawYesNo(graph) {
		graph.append("div").attr("class", "jumbotron").append("h5").style("color", "#222").html("Yes/No questions aren't supported yet :(  Try another question!");
		return graph;
	}

}
